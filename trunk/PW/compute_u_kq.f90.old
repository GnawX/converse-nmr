!
! Copyright (C) 2001-2006 Quantum-ESPRESSO group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
#include "f_defs.h"
!
!----------------------------------------------------------------------------
SUBROUTINE compute_u_kq(ik, q, iter, dr2)
  !----------------------------------------------------------------------------
  !
  ! ... diagonalize the wfc at k+q
  !
  USE kinds,                ONLY : DP
  USE io_global,            ONLY : stdout
  USE wvfct,                ONLY : gamma_only
  USE io_files,             ONLY : iunigk, nwordatwfc, iunsat, iunwfc, nwordwfc, iunefield,&
                                     &iunefieldp,iunefieldm
  USE cell_base,            ONLY : tpiba2 
  USE klist,                ONLY : nkstot, nks, wk, xk, nelec
  USE uspp,                 ONLY : vkb, nkb, okvan
  USE gvect,                ONLY : g, gstart, ecfixed, qcutz, q2sigma, nrxx, &
                                   nr1, nr2, nr3  
  USE wvfct,                ONLY : g2kin, wg, et, nbndx, nbnd, npwx, igk, &
                                   npw, current_k, btype
  USE control_flags,        ONLY : diis_ndim, ethr, lscf, max_cg_iter, &
                                   isolve, istep, reduce_io, conv_ions
  USE ldaU,                 ONLY : lda_plus_u, swfcatom
  USE scf,                  ONLY : vltot
  USE lsda_mod,             ONLY : current_spin, lsda, isk
  USE noncollin_module,     ONLY : noncolin, npol
  USE wavefunctions_module, ONLY : evc
  USE g_psi_mod,            ONLY : h_diag, s_diag, h_diag_nc, s_diag_nc
  USE bp,                   ONLY : lelfield, evcel, evcelp, evcelm, bec_evcel
  IMPLICIT NONE
  INTEGER :: ik, iter
  REAL(DP) :: dr2, q(3)
  REAL(DP) :: avg_iter, cg_iter, v_of_0
  INTEGER :: ig, dav_iter, diis_iter, ntry, notconv
  LOGICAL :: lrot
  REAL(DP), EXTERNAL :: erf

  CALL start_clock( 'c_bands' )

  IF ( noncolin ) THEN
     ALLOCATE( h_diag_nc( npwx, npol ) )
     ALLOCATE( s_diag_nc( npwx, npol ) )
  ELSE
     ALLOCATE( h_diag( npwx ) )
     ALLOCATE( s_diag( npwx ) )
  END IF

  IF ( lelfield ) THEN
    ALLOCATE( evcel( npwx, nbnd ) )
    ALLOCATE( evcelm( npwx, nbnd ) )
    ALLOCATE( evcelp( npwx, nbnd ) )
    ALLOCATE( bec_evcel(nkb,nbnd) )
  END IF

  IF ( gamma_only ) THEN
     CALL errore('compute_u_kq', 'gamma_only == .true. ???', 1)
  ELSE
     CALL do_it()
  END IF

  IF ( noncolin ) THEN
     DEALLOCATE( s_diag_nc )
     DEALLOCATE( h_diag_nc )
  ELSE
     DEALLOCATE( s_diag )
     DEALLOCATE( h_diag )
  END IF

  IF ( lelfield ) THEN
     DEALLOCATE( evcel )
     DEALLOCATE( evcelm )
     DEALLOCATE( evcelp )
     DEALLOCATE( bec_evcel)
  END IF
  CALL stop_clock( 'c_bands' )  
  RETURN


  CONTAINS
     !-----------------------------------------------------------------------
     SUBROUTINE do_it()
     !-----------------------------------------------------------------------
     USE becmod,              ONLY : becp, becp_nc
     USE complex_diis_module, ONLY : cdiisg
     USE control_flags,       ONLY : lbands
     USE check_stop,          ONLY : check_stop_now
     USE gvect,     ONLY : nr1, nr2, nr3, ngm, ecutwfc, g
     IMPLICIT NONE
     INTEGER :: ipol
     REAL :: xkold(3)
     REAL, allocatable :: etq(:,:)

     lscf = .false.
     allocate(etq(nbndx,nks))

     IF ( noncolin ) THEN
       ALLOCATE( becp_nc( nkb, npol, nbnd ) )
     ELSE
       ALLOCATE( becp( nkb, nbnd ) )
     END IF

     IF ( isolve == 0 ) THEN
        WRITE( stdout, '(5X,"Davidson diagonalization with overlap")')
     ELSE IF ( isolve == 1 ) THEN
        WRITE( stdout, '(5X,"CG style diagonalization")')
     ELSE IF ( isolve == 2 ) THEN
        WRITE( stdout, '(5X,"DIIS style diagonalization")')
     ELSE
        CALL errore( 'c_bands', 'isolve not implemented', 1 )
     END IF

     avg_iter = 0.D0

     ! ... v_of_0 is (Vloc)(G=0)
     v_of_0 = SUM( vltot(1:nrxx) ) / DBLE( nr1 * nr2 * nr3 )
#ifdef __PARA
     CALL reduce( 1, v_of_0 )
#endif

     ! do the k+G ordering for k (not k+q)
     call gk_sort( xk(1,ik), ngm, g, ecutwfc / tpiba2, npw, igk, g2kin )
     xkold(:) = xk(:,ik)
     xk(:,ik) = xk(:,ik) + q(:)

     ! ... read wave function for electric field
     IF ( lelfield ) THEN
        CALL davcio( evcel, nwordwfc, iunefield, ik, -1 )
        !read projectors on disk
        CALL davcio(evcelm,nwordwfc,iunefieldm,ik,-1)
        CALL davcio(evcelp,nwordwfc,iunefieldp,ik,-1)
     END IF

     current_k = ik
     IF ( lsda ) current_spin = isk(ik)

     ! ... various initializations
     IF ( nkb > 0 ) THEN
       CALL init_us_2( npw, igk, xk(1,ik), vkb )
     ENDIF
     IF (okvan.and.lelfield) THEN
       CALL ccalbec(nkb,npwx,npw,nbnd,bec_evcel,vkb,evcel)
     ENDIF

     ! ... read in wavefunctions
     CALL davcio( evc, nwordwfc, iunwfc, ik, -1 )

     ! ... Needed for LDA+U
     IF ( lda_plus_u ) CALL davcio( swfcatom, nwordatwfc, iunsat, ik, -1 )

     ! ... sets the kinetic energy
     g2kin(1:npw) = ( ( xk(1,ik) + g(1,igk(1:npw)) )**2 + &
                      ( xk(2,ik) + g(2,igk(1:npw)) )**2 + &
                      ( xk(3,ik) + g(3,igk(1:npw)) )**2 ) * tpiba2
     IF ( qcutz > 0.D0 ) THEN
       DO ig = 1, npw
         g2kin(ig) = g2kin(ig) + qcutz * &
                     ( 1.D0 + erf( ( g2kin(ig) - ecfixed ) / q2sigma ) )
       END DO
     END IF

     !-----------------------------------------------------------------
     ! ... Conjugate-Gradient diagonalization
     !-----------------------------------------------------------------
     IF ( isolve == 1 ) THEN
       IF ( noncolin ) THEN
         h_diag_nc = 1.D0
         FORALL( ig = 1 : npwx )
           h_diag_nc(ig,:) = 1.D0 + g2kin(ig) + &
                             SQRT( 1.D0 + ( g2kin(ig) - 1.D0 )**2 )
         END FORALL
       ELSE
         h_diag = 1.D0
         FORALL( ig = 1 : npw )
           h_diag(ig) = 1.D0 + g2kin(ig) + &
                        SQRT( 1.D0 + ( g2kin(ig) - 1.D0 )**2 )
         END FORALL
       END IF

       ntry = 0
       CG_loop : DO
         IF ( iter > 1 .OR. istep > 0 .OR. ntry > 0 ) THEN
           CALL cinitcgg( npwx, npw, nbnd, nbnd, evc, evc, etq(1,ik),.false. )
           avg_iter = avg_iter + 1.D0
         END IF
         IF ( noncolin ) THEN
           CALL ccgdiagg( npwx, npw, nbnd, evc, etq(1,ik), btype(1,ik), &
                          h_diag_nc, ethr, max_cg_iter, .NOT. lscf, &
                          notconv, cg_iter )
         ELSE
           CALL ccgdiagg( npwx, npw, nbnd, evc, etq(1,ik), btype(1,ik), &
                          h_diag, ethr, max_cg_iter, .NOT. lscf, &
                          notconv, cg_iter )
         END IF
         avg_iter = avg_iter + cg_iter
         ntry = ntry + 1                
         IF ( test_exit_cond() ) EXIT  CG_loop
       END DO CG_loop


     !-----------------------------------------------------------------
     ! ... RMM-DIIS method (better not to use it!)
     !-----------------------------------------------------------------
     ELSE IF ( isolve == 2 ) THEN
       IF ( noncolin ) THEN
         DO ipol = 1, npol
           h_diag_nc(1:npw,ipol) = g2kin(1:npw) + v_of_0
         END DO
       ELSE
           h_diag(1:npw) = g2kin(1:npw) + v_of_0
       END IF

       CALL usnldiag( h_diag_nc, s_diag_nc )
       ntry = 0
       RMMDIIS_loop: DO
         IF ( noncolin ) THEN
           CALL cdiisg_nc( npw, npwx, nbnd, diis_ndim, &
                           evc, etq(1,ik), ethr, btype(1,ik), &
                           notconv, diis_iter, iter, npol )
         ELSE
           CALL cdiisg( npw, npwx, nbnd, evc, et(1,ik), &
                        btype(1,ik), notconv, diis_iter, iter )
         END IF
         avg_iter = avg_iter + diis_iter
         ntry = ntry + 1                
         IF ( test_exit_cond() ) EXIT  RMMDIIS_loop
       END DO RMMDIIS_loop


     !-----------------------------------------------------------------
     ! ... Davidson diagonalization
     !-----------------------------------------------------------------
     ELSE
       IF ( noncolin ) THEN
         DO ipol = 1, npol
           h_diag_nc(1:npw,ipol) = g2kin(1:npw) + v_of_0
         END DO
         CALL usnldiag_nc( h_diag_nc, s_diag_nc )
       ELSE
         h_diag(1:npw) = g2kin(1:npw) + v_of_0
         CALL usnldiag( h_diag, s_diag )
       END IF

       ntry = 0
       david_loop: DO
         lrot = ( iter == 1 )
         CALL cegterg( npw, npwx, nbnd, nbndx, evc, ethr, &
                       okvan, etq(1,ik), btype(1,ik), notconv, &
                       lrot, dav_iter )
         avg_iter = avg_iter + dav_iter
         ntry = ntry + 1                
         IF ( test_exit_cond() ) EXIT david_loop             
       END DO david_loop 

     END IF

     IF ( notconv > MAX( 5, nbnd / 4 ) ) &
       CALL errore( 'comput_u_kq', 'too many bands are not converged', 1 )

     IF ( noncolin ) THEN
       DEALLOCATE( becp_nc )
     ELSE
       DEALLOCATE( becp )
     END IF

     print*, etq(1:nbnd,1)*13.605692d0
     ! restore old k-point
     xk(:,ik) = xkold(:)
     RETURN

     END SUBROUTINE do_it


     !-----------------------------------------------------------------------
     FUNCTION test_exit_cond()
     !-----------------------------------------------------------------------
     ! ... this logical function is .TRUE. when iterative diagonalization
     ! ... is converged
     IMPLICIT NONE
     LOGICAL :: test_exit_cond
     test_exit_cond = .NOT. ( ( ntry <= 5 ) .AND. &
                            ( ( .NOT. lscf .AND. ( notconv > 0 ) ) .OR. &
                            (       lscf .AND. ( notconv > 5 ) ) ) )
     END FUNCTION test_exit_cond

END SUBROUTINE compute_u_kq

