!
! Copyright (C) 2001-2005 Quantum-ESPRESSO group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
!-----------------------------------------------------------------------
MODULE orbital_magnetization
  !-----------------------------------------------------------------------
  !
  ! ... the title is self explaining
  !
  USE kinds, ONLY : DP
  IMPLICIT NONE
  SAVE
  REAL(DP) :: orb_magn_LC(3)
  REAL(DP) :: orb_magn_IC(3)
  REAL(DP) :: orb_magn_bare(3)
  REAL(DP) :: orb_magn_Fnl(3)
  REAL(DP) :: berry_curvature(3)
  REAL(DP) :: orb_magn_tot(3)
  REAL(DP) :: delta_linear_response(3)
  REAL(DP) :: delta_M_bare(3)
  REAL(DP) :: delta_M_Fnl(3)
  COMPLEX(dp), ALLOCATABLE :: dbecp(:,:,:)
  COMPLEX(dp), ALLOCATABLE :: paw_dbecp(:,:,:)

  real(dp), parameter :: q_gipaw = 0.02_dp
  real(dp) :: delta_k

  LOGICAL :: torbmagn 
  CHARACTER(80) :: dudk
  
CONTAINS

  !-----------------------------------------------------------------------
  SUBROUTINE calc_orbital_magnetization
  !-----------------------------------------------------------------------
  USE kinds,                ONLY : dp
  USE io_files,             ONLY : nwordwfc, iunwfc  
  USE wvfct,                ONLY : npw, g2kin, igk, nbnd, npwx, wg, et, &
                                   current_k
  USE klist,                ONLY : xk, nks, lgauss
  USE gsmooth,              ONLY : nrxxs
  USE cell_base,            ONLY : tpiba2, tpiba
  USE gvect,                ONLY : nr1, nr2, nr3, ngm, ecutwfc, g
  USE io_global,            ONLY : stdout
  USE uspp,                 ONLY : nkb, vkb
  USE becmod,               ONLY : becp
  USE wavefunctions_module, ONLY : evc
  USE lsda_mod,             ONLY : current_spin, lsda, isk, nspin
  USE g_tensor_module,      ONLY : lambda_so, add_so_Fnl, calc_g_tensor
  USE paw,                  ONLY : paw_vkb
  USE ener,                 ONLY : ef
  USE control_flags,        ONLY : iverbosity
  USE paw,                  ONLY : paw_nkb, paw_becp
  USE buffers,              ONLY : get_buffer
  USE scf,                  ONLY : dvrs, vrs
  USE mp_global,            ONLY : my_pool_id, me_pool, root_pool
  USE mp,                   ONLY : mp_barrier
  implicit none
  complex(dp), external :: ZDOTC
  integer, parameter :: iundudk1 = 75, iundudk2 = 76, iundudk3 = 77
  real(dp), parameter :: rydtohar = 0.5d0
  complex(dp), allocatable :: dudk_bra(:,:), dudk_ket(:,:), hpsi(:)
  complex(dp), allocatable :: vkb_save(:,:), aux(:,:)
  complex(dp) :: braket
  real(dp) :: kp_berry(3), kp_M_LC(3), kp_M_IC(3), tmp1(3), tmp2(3)
  integer :: ik, ibnd, jbnd, kk, ii, jj, occ
  real(dp) :: tmp(3), emin, emax
  ! index for the cross product
  integer :: ind(2,3)
  ind(:,1) = (/ 2, 3 /)
  ind(:,2) = (/ 3, 1 /)
  ind(:,3) = (/ 1, 2 /)

  ! set delta_k
  delta_k = q_gipaw/2.d0/tpiba

  ! compute the covariant derivatives
  call compute_dudk(dudk)

  ! allocate memory
  allocate (dudk_bra(npwx,nbnd), dudk_ket(npwx,nbnd), hpsi(npwx))

  ! zero the accumulators
#ifdef __PARA
  CALL mp_barrier()
#endif
  write(stdout,*)
  write(stdout,'(5X,''Computing the orbital magnetization (bohr mag/cell):'')')
  orb_magn_LC = 0.d0
  orb_magn_IC = 0.d0
  orb_magn_Fnl = 0.d0
  orb_magn_tot = 0.d0
  berry_curvature = 0.d0
  delta_M_bare = 0.d0
  delta_M_Fnl = 0.d0
  delta_linear_response = 0.d0
  orb_magn_bare = 0.d0  

  ! allocate the derivatives of the projectors
  allocate(becp(nkb,nbnd), dbecp(nkb,nbnd,3), paw_dbecp(paw_nkb,nbnd,3))
  allocate(vkb_save(npwx,nkb), aux(nkb,nbnd))   

  ! set the external potential
  call set_dvrs(dvrs, vrs, nrxxs, nspin)

  ! loop over k-points
  do ik = 1, nks
    call find_nbnd_occ(ik, occ, emin, emax)
    if (lgauss) occ = nbnd

    ! setup the hamiltonian
    current_k = ik
    current_spin = 1
    if (lsda) current_spin = isk(ik)
    call gk_sort(xk(1,ik), ngm, g, ecutwfc/tpiba2, npw, igk, g2kin)
    g2kin(1:npw) = g2kin(1:npw) * tpiba2
    call get_buffer(evc, nwordwfc, iunwfc, ik)
    if (nkb > 0) then
      call init_us_2(npw, igk, xk(1,ik), vkb)
      call ccalbec(nkb, npwx, npw, nbnd, becp, vkb, evc)
    endif
    call init_paw_2(npw, igk, xk(1,ik), paw_vkb)
    call compute_dbecp
    call compute_paw_dbecp

    ! loop over the magnetization directions
    do kk =  1, 3
      ii = ind(1,kk)
      jj = ind(2,kk)

      ! read the bra and the ket
      call davcio(dudk_bra, 2*nwordwfc, iundudk1 + ii - 1, ik, -1)
      call davcio(dudk_ket, 2*nwordwfc, iundudk1 + jj - 1, ik, -1)

      ! compute the orbital magnetization
      kp_berry(kk) = 0.d0
      kp_M_IC(kk) = 0.d0
      kp_M_LC(kk) = 0.d0
      do ibnd = 1, occ
        ! IC term and Berry curvature
        braket = zdotc(npw, dudk_bra(1,ibnd), 1, dudk_ket(1,ibnd), 1)
        kp_berry(kk) = kp_berry(kk) + 2.d0*wg(ibnd,ik)*imag(braket)
        berry_curvature(kk) = berry_curvature(kk) + &
                              2.d0*wg(ibnd,ik)*imag(braket)
        kp_M_IC(kk) = kp_M_IC(kk) + 2.d0*wg(ibnd,ik)*et(ibnd,ik)*imag(braket)
        orb_magn_IC(kk) = orb_magn_IC(kk) + &
                         2.d0*wg(ibnd,ik)*et(ibnd,ik)*imag(braket)

        ! this is the LC term
        !! this is the bare term
        call h_psi_bare(npwx, npw, 1, dudk_ket(1:npwx,ibnd), hpsi)
        braket = zdotc(npw, dudk_bra(1,ibnd), 1, hpsi, 1)
        kp_M_LC(kk) = kp_M_LC(kk) + wg(ibnd,ik)*imag(braket)
        orb_magn_bare(kk) = orb_magn_bare(kk) + wg(ibnd,ik)*imag(braket)

        call h_psi_bare(npwx, npw, 1, dudk_bra(1:npwx,ibnd), hpsi)
        braket = zdotc(npw, dudk_ket(1,ibnd), 1, hpsi, 1)
        kp_M_LC(kk) = kp_M_LC(kk) - wg(ibnd,ik)*imag(braket)
        orb_magn_bare(kk) = orb_magn_bare(kk) - wg(ibnd,ik)*imag(braket)

        !! this is the Fnl term alone
        if (all(lambda_so == 0.d0)) cycle
        hpsi = (0.d0,0.d0)
        call add_so_Fnl(npwx, npw, 1, 1.d0, dudk_ket(1:npwx,ibnd), hpsi)
        braket = zdotc(npw, dudk_bra(1,ibnd), 1, hpsi, 1)
        kp_M_LC(kk) = kp_M_LC(kk) + wg(ibnd,ik)*imag(braket)
        orb_magn_Fnl(kk) = orb_magn_Fnl(kk) + wg(ibnd,ik)*imag(braket)

        hpsi = (0.d0,0.d0)
        call add_so_Fnl(npwx, npw, 1, 1.d0, dudk_bra(1:npwx,ibnd), hpsi)
        braket = zdotc(npw, dudk_ket(1,ibnd), 1, hpsi, 1)
        kp_M_LC(kk) = kp_M_LC(kk) - wg(ibnd,ik)*imag(braket)
        orb_magn_Fnl(kk) = orb_magn_Fnl(kk) - wg(ibnd,ik)*imag(braket)
      enddo

      ! compute the GIPAW corrections
      call calc_delta_M_bare
      call calc_delta_M_Fnl
    enddo ! kk
#ifdef __PARA
    call reduce(3, kp_berry)
    call reduce(3, kp_M_LC)
    call reduce(3, kp_M_IC)
#endif
    if (me_pool == root_pool) &
      write(*,'(5X,''k-point:'',I4,4X,''pool:'',I4,4X,3(F10.4),/,5X,(9F12.6))') &
            ik, my_pool_id+1, xk(:,ik), kp_berry, kp_M_LC*rydtohar, kp_M_IC*rydtohar
  enddo ! ik

#ifdef __PARA
  call reduce(3, orb_magn_bare)
  call reduce(3, orb_magn_IC)
  call reduce(3, orb_magn_Fnl)
  call reduce(3, berry_curvature)
  ! no reduction for delta_M_bare and delta_M_Fnl
#endif

#ifdef __PARA
  call poolreduce(3, orb_magn_bare)
  call poolreduce(3, orb_magn_IC)
  call poolreduce(3, orb_magn_Fnl)
  call poolreduce(3, berry_curvature)
  call poolreduce(3, delta_M_bare)
  call poolreduce(3, delta_M_Fnl)
#endif

  ! close files
  close(unit=iundudk1, status='keep')
  close(unit=iundudk2, status='keep')
  close(unit=iundudk3, status='keep')

  !!orb_magn_bare = orb_magn_LC - orb_magn_Fnl

  ! convert to hartree and sum up all terms
  ef = ef * rydtohar
  orb_magn_LC = orb_magn_LC * rydtohar
  orb_magn_bare = orb_magn_bare * rydtohar
  orb_magn_Fnl = orb_magn_Fnl * rydtohar
  orb_magn_IC = orb_magn_IC * rydtohar
  delta_M_bare = delta_M_bare * rydtohar
  delta_M_Fnl = delta_M_Fnl * rydtohar
  
  !<uwge> correction of the Fnl-terms:  a2gp4 ---> a2gp8
  !orb_magn_Fnl = 0.5 * orb_magn_Fnl
  !delta_M_Fnl  = 0.5 * delta_M_Fnl
  orb_magn_LC  = orb_magn_bare + delta_M_bare + orb_magn_Fnl + delta_M_Fnl
  orb_magn_tot = orb_magn_LC + orb_magn_IC

  delta_linear_response = 0.5 * ( orb_magn_Fnl + delta_M_Fnl )
  !<\uwge>

  !write(stdout,'(3E14.4)') orb_magn_LC
  !write(stdout,'(3E14.4)') orb_magn_Fnl
  !write(stdout,'(3E14.4)') orb_magn_IC
  !write(stdout,'(3E14.4)') orb_magn_tot
  !write(stdout,'(3E14.4)') berry_curvature

  ! print results
  write(stdout,'(5X,''lambda_so          = '',3(F14.6))') lambda_so
  write(stdout,'(5X,''Berry curvature    = '',3(F14.6))') berry_curvature
  write(stdout,'(5X,''Fermi energy       = '',F14.6,'' hartree'')') ef
  !write(stdout,'(5X,''Fermi energy       = '',F14.6,'' hartree'')') ef*rydtohar
  write(stdout,*)
  if (iverbosity > 0) then
    write(stdout,'(5X,''(without Berry curvature term)'')')
    write(stdout,'(5X,''M_LC               = '',3(F14.6))') orb_magn_LC
    write(stdout,'(5X,''  M_LC (bare)      = '',3(F14.6))') orb_magn_bare
    write(stdout,'(5X,''  Delta M_LC (bare)= '',3(F14.6))') delta_M_bare
    write(stdout,'(5X,''  M_LC (F_NL)      = '',3(F14.6))') orb_magn_Fnl
    write(stdout,'(5X,''  Delta M_LC (F_NL)= '',3(F14.6))') delta_M_Fnl
    write(stdout,'(5X,''M_IC               = '',3(F14.6))') orb_magn_IC
    write(stdout,'(5X,''M_tot              = '',3(F14.6))') orb_magn_tot
    write(stdout,*)
    write(stdout,'(5X,''(with Berry curvature term)'')')
  endif
  orb_magn_LC = orb_magn_LC - ef*berry_curvature
  orb_magn_IC = orb_magn_IC - ef*berry_curvature
  orb_magn_tot = orb_magn_tot - 2.d0*ef*berry_curvature
  write(stdout,'(5X,''M_LC               = '',3(F14.6))') orb_magn_LC
  write(stdout,'(5X,''M_IC               = '',3(F14.6))') orb_magn_IC
  write(stdout,'(5X,''M_tot              = '',3(F14.6))') orb_magn_tot
  
  ! free memory
  deallocate( dudk_bra, dudk_ket, hpsi, becp )

  ! close files
  close(unit=iundudk1)
  close(unit=iundudk2)
  close(unit=iundudk3)

  ! go on, reporting the g-tensor
  if (any(lambda_so /= 0.d0)) &
    call calc_g_tensor(orb_magn_tot,delta_linear_response)


  CONTAINS
    ! derivative of the beta's
    SUBROUTINE compute_dbecp
    USE cell_base, ONLY : tpiba
    USE g_tensor_module, ONLY : init_us_2_no_phase
    implicit none
    integer :: ipol, sig
    real(dp) :: kq(3)
    if (nkb == 0) return
    vkb_save = vkb
    do ipol = 1, 3
      dbecp(:,:,ipol) = (0.d0,0.d0)
      do sig = -1, 1, 2
        kq(:) = xk(:,ik)
        kq(ipol) = kq(ipol) + sig * delta_k
        call init_us_2_no_phase(npw, igk, kq, vkb)
        call ccalbec(nkb, npwx, npw, nbnd, aux, vkb, evc)
        dbecp(:,:,ipol) = dbecp(:,:,ipol) + &
                          0.5d0*sig/(delta_k*tpiba) * aux(:,:)
      enddo
    enddo
    vkb = vkb_save
    END SUBROUTINE compute_dbecp

    ! GIPAW correction to M_bare
    SUBROUTINE calc_delta_M_bare
    USE ions_base,  ONLY : nat, ntyp => nsp, ityp
    USE uspp_param, ONLY : nh
    USE uspp,       ONLY : deeq
    implicit none
    complex(dp) :: tmp, becp_product
    integer :: ibnd, ijkb0, nt, na, jh, jkb, ih, ikb
    if (nkb == 0) return
    tmp = (0.d0,0.d0)
    do ibnd = 1, occ
      ijkb0 = 0
      do nt = 1, ntyp
        do na = 1, nat
          if ( ityp(na) == nt ) then
            do jh = 1, nh(nt)
              jkb = ijkb0 + jh
              do ih = 1, nh(nt)
                ikb = ijkb0 + ih
                becp_product = conjg(dbecp(ikb,ibnd,ii)) * dbecp(jkb,ibnd,jj)
                tmp = tmp + wg(ibnd,ik) * deeq(ih,jh,na,current_spin) * &
                            becp_product
              enddo
            enddo
            ijkb0 = ijkb0 + nh(nt)
          endif
        enddo
      enddo
    enddo
    !!PRINT*, kk, -2.d0*tmp
    ! check the sign and real or imag!!
    delta_M_bare(kk) = delta_M_bare(kk) - 2.d0*imag(tmp)
    END SUBROUTINE calc_delta_M_bare

      
    ! derivative of GIPAW projectors
    SUBROUTINE compute_paw_dbecp
    USE cell_base, ONLY : tpiba
    implicit none
    integer :: ipol, sig
    real(dp) :: kq(3)
    if (paw_nkb == 0) return
    do ipol = 1, 3
      paw_dbecp(:,:,ipol) = (0.d0,0.d0)
      do sig = -1, 1, 2
        kq(:) = xk(:,ik)
        kq(ipol) = kq(ipol) + sig * delta_k  
        call init_paw_2(npw, igk, kq, paw_vkb)
        call ccalbec(paw_nkb, npwx, npw, nbnd, paw_becp, paw_vkb, evc)
        paw_dbecp(:,:,ipol) = paw_dbecp(:,:,ipol) + &
                              0.5d0*sig/(delta_k*tpiba) * paw_becp(:,:)
      enddo
    enddo
    END SUBROUTINE compute_paw_dbecp

    ! GIPAW correction to M_Fnl
    SUBROUTINE calc_delta_M_Fnl
    USE ions_base,  ONLY : nat, ntyp => nsp, ityp
    USE uspp_param, ONLY : nh
    USE uspp,       ONLY : deeq  
    USE paw,        ONLY : paw_vkb, paw_nkb, paw_recon, paw_lmaxkb
    USE g_tensor_module, ONLY : a2gp4, a2gp8, radial_integral_paramagnetic_so
    USE g_tensor_module, ONLY : lx, ly, lz
    implicit none
    complex(dp) :: tmp, becp_product
    integer :: ibnd, ijkb0, nt, na, jh, jkb, ih, ikb
    integer :: l1, m1, lm1, l2, m2, lm2, nbs1, nbs2
    real(dp) :: sigma
    if (paw_nkb == 0) return  
    sigma = 1.d0; if (current_spin == 2) sigma = -1.d0
    tmp = (0.d0,0.d0)
    ijkb0 = 0
    do nt = 1, ntyp
      do na = 1, nat
        if (ityp(na) .eq. nt) then
          do ih = 1, paw_recon(nt)%paw_nh
            ikb = ijkb0 + ih
            nbs1 = paw_recon(nt)%paw_indv(ih)
            l1 = paw_recon(nt)%paw_nhtol(ih)
            m1 = paw_recon(nt)%paw_nhtom(ih)
            lm1 = m1 + l1**2
            do jh = 1, paw_recon(nt)%paw_nh
              jkb = ijkb0 + jh
              nbs2 = paw_recon(nt)%paw_indv(jh)
              l2 = paw_recon(nt)%paw_nhtol(jh)
              m2 = paw_recon(nt)%paw_nhtom(jh)
              lm2 = m2 + l2**2
              if ( l1 /= l2 ) cycle
              if (l1 == 0) cycle
              do ibnd = 1, occ
                becp_product = conjg(paw_dbecp(ikb,ibnd,ii)) * &
                                     paw_dbecp(jkb,ibnd,jj)
                tmp = tmp + lambda_so(1) * a2gp8 * &
                      sigma * lx(lm1,lm2) * (0.d0,1.d0) * &
                      radial_integral_paramagnetic_so(nbs1,nbs2,nt) * &
                      wg(ibnd,ik) * becp_product
                tmp = tmp + lambda_so(2) * a2gp8 * &
                      sigma * ly(lm1,lm2) * (0.d0,1.d0) * &
                      radial_integral_paramagnetic_so(nbs1,nbs2,nt) * &
                      wg(ibnd,ik) * becp_product
                tmp = tmp + lambda_so(3) * a2gp8 * &
                      sigma * lz(lm1,lm2) * (0.d0,1.d0) * &
                      radial_integral_paramagnetic_so(nbs1,nbs2,nt) * &
                      wg(ibnd,ik) * becp_product
              enddo   ! ibnd
            enddo   ! jh
          enddo   ! ih
          ijkb0 = ijkb0 + paw_recon(nt)%paw_nh
        endif   ! if (ityp...
      enddo   ! na
    enddo  ! nt
    !!PRINT*, kk, tmp
    ! check the sign and real or imag!!
    delta_M_Fnl(kk) = delta_M_Fnl(kk) - 2.d0*imag(tmp)
    END SUBROUTINE calc_delta_M_Fnl

  END SUBROUTINE calc_orbital_magnetization

!-----------------------------------------------------------------------
END MODULE orbital_magnetization
!-----------------------------------------------------------------------

